@using System.Collections.Generic
@using System.Linq
@using System.Text.RegularExpressions

<div class="card">
    <div class="card-body">
        <form @onsubmit="HandleSubmit">
            @foreach (var field in Fields)
            {
                @if (IsFieldVisible(field))
                {
                    var nestingLevel = GetNestingLevel(field);
                    var marginLeft = nestingLevel * 24; // 24px per nesting level

                    <div class="mb-3" style="@(nestingLevel > 0 ? $"margin-left: {marginLeft}px; padding-left: 12px; border-left: 2px solid #dee2e6;" : "")">
                        @if (field.Type != FormFieldType.Checkbox && field.Type != FormFieldType.StaticText && field.Type != FormFieldType.RadioGroup)
                        {
                            <label class="form-label">@((MarkupString)ReplaceVariables(field.Label, field))</label>
                        }

                        @switch (field.Type)
                        {
                            case FormFieldType.Text:
                                <input class="form-control"
                                       type="text"
                                       placeholder="@field.Placeholder"
                                       value="@GetStringValue(field.Key)"
                                       @oninput="e => SetStringValue(field.Key, e.Value?.ToString())" />
                                break;

                            case FormFieldType.Number:
                                <input class="form-control"
                                       type="number"
                                       placeholder="@field.Placeholder"
                                       value="@GetStringValue(field.Key)"
                                       @oninput="e => SetStringValue(field.Key, e.Value?.ToString())" />
                                break;

                            case FormFieldType.Date:
                                <input class="form-control"
                                       type="date"
                                       value="@GetStringValue(field.Key)"
                                       @oninput="e => SetStringValue(field.Key, e.Value?.ToString())" />
                                break;

                            case FormFieldType.Checkbox:
                                <div class="form-check">
                                    <input class="form-check-input"
                                           type="checkbox"
                                           checked="@(GetBoolValue(field.Key))"
                                           @onchange="e => SetCheckboxValue(field.Key, (bool?)e.Value ?? false)" />
                                    <label class="form-check-label">@((MarkupString)ReplaceVariables(field.CheckboxLabel ?? field.Label, field))</label>
                                </div>
                                break;

                            case FormFieldType.RadioGroup:
                                @if (field.Options is not null && field.Options.Count > 0)
                                {
                                    @foreach (var option in field.Options)
                                    {
                                        <div class="form-check">
                                            <input class="form-check-input"
                                                   type="radio"
                                                   name="@field.Key"
                                                   id="@($"{field.Key}_{option.Value}")"
                                                   value="@option.Value"
                                                   checked="@(GetStringValue(field.Key) == option.Value)"
                                                   @onchange="e => SetStringValue(field.Key, option.Value)" />
                                            <label class="form-check-label" for="@($"{field.Key}_{option.Value}")">
                                                @((MarkupString)ReplaceVariablesForOption(option.Text, field))
                                            </label>
                                        </div>
                                    }
                                }
                                break;

                            case FormFieldType.Select:
                                <select class="form-select"
                                        value="@GetStringValue(field.Key)"
                                        @onchange="e => SetStringValue(field.Key, e.Value?.ToString())">
                                    @if (!string.IsNullOrWhiteSpace(field.Placeholder))
                                    {
                                        <option value="">@field.Placeholder</option>
                                    }

                                    @if (field.Options is not null)
                                    {
                                        @foreach (var option in field.Options)
                                        {
                                            <option value="@option.Value">@option.Text</option>
                                        }
                                    }
                                </select>
                                break;

                            case FormFieldType.StaticText:
                                <p class="mb-0 fw-semibold">@((MarkupString)ReplaceVariables(field.Label, field))</p>
                                break;
                        }

                        @if (!string.IsNullOrWhiteSpace(field.HelpText))
                        {
                            <div class="form-text">@((MarkupString)ReplaceVariables(field.HelpText, field))</div>
                        }
                    </div>
                }
            }

            @* Always show total if there are priced fields *@
            @if (HasPricedFields)
            {
                <div class="card bg-light mb-3">
                    <div class="card-body py-2">
                        <div class="d-flex justify-content-between align-items-center">
                            <span class="fw-bold">Grand Total:</span>
                            <span class="text-success fw-bold fs-4">@CalculateTotal().ToString("C")</span>
                        </div>
                    </div>
                </div>
            }

            <button type="submit" class="btn btn-primary">@SubmitText</button>
        </form>
    </div>
</div>

@code {
    [Parameter]
    public List<FormField> Fields { get; set; } = new();

    [Parameter]
    public string SubmitText { get; set; } = "Submit";

    /// <summary>
    /// The current form values. The key is the field Key, the value is the user input.
    /// </summary>
    [Parameter]
    public Dictionary<string, object?> Values { get; set; } = new();

    /// <summary>
    /// Fired when the user submits the form.
    /// </summary>
    [Parameter]
    public EventCallback<Dictionary<string, object?>> OnSubmit { get; set; }

    protected override void OnInitialized()
    {
        // Ensure all fields have an entry in the values dictionary
        foreach (var field in Fields)
        {
            if (field.Type != FormFieldType.StaticText && !Values.ContainsKey(field.Key))
            {
                Values[field.Key] = field.DefaultValue;
            }
        }
    }

    private async Task HandleSubmit()
    {
        if (OnSubmit.HasDelegate)
        {
            await OnSubmit.InvokeAsync(Values);
        }
    }

    #region Nesting / Conditional Visibility

    /// <summary>
    /// Check if a field should be visible based on its parent's state.
    /// </summary>
    private bool IsFieldVisible(FormField field)
    {
        // No parent = always visible
        if (string.IsNullOrEmpty(field.ParentFieldKey))
            return true;

        // Find the parent field
        var parent = Fields.FirstOrDefault(f => f.Key == field.ParentFieldKey);
        if (parent == null)
            return true; // Parent not found, show anyway

        // Check if parent is visible first (recursive)
        if (!IsFieldVisible(parent))
            return false;

        // StaticText parent = always show children (no condition)
        if (parent.Type == FormFieldType.StaticText)
        {
            return true;
        }

        // Checkbox parent = must be checked
        if (parent.Type == FormFieldType.Checkbox)
        {
            return GetBoolValue(parent.Key);
        }

        // For other parent types, show if parent has a value
        var parentValue = GetStringValue(parent.Key);
        return !string.IsNullOrEmpty(parentValue);
    }

    /// <summary>
    /// Get the nesting level of a field (0 = root, 1 = child, 2 = grandchild, etc.)
    /// </summary>
    private int GetNestingLevel(FormField field)
    {
        int level = 0;
        var currentKey = field.ParentFieldKey;

        while (!string.IsNullOrEmpty(currentKey))
        {
            level++;
            var parent = Fields.FirstOrDefault(f => f.Key == currentKey);
            currentKey = parent?.ParentFieldKey;

            // Safety check to prevent infinite loops
            if (level > 10) break;
        }

        return level;
    }

    /// <summary>
    /// Clear values of all child fields when a parent is unchecked.
    /// </summary>
    private void ClearChildValues(string parentKey)
    {
        var children = Fields.Where(f => f.ParentFieldKey == parentKey);
        foreach (var child in children)
        {
            if (child.Type == FormFieldType.Checkbox)
            {
                Values[child.Key] = false;
            }
            else if (child.Type == FormFieldType.RadioGroup)
            {
                Values[child.Key] = null;
            }
            else if (child.Type != FormFieldType.StaticText)
            {
                Values[child.Key] = null;
            }

            // Recursively clear grandchildren
            ClearChildValues(child.Key);
        }
    }

    #endregion

    #region Value Getters/Setters

    private string GetStringValue(string key)
    {
        if (Values.TryGetValue(key, out var value) && value is not null)
        {
            return Convert.ToString(value) ?? string.Empty;
        }

        return string.Empty;
    }

    private void SetStringValue(string key, string? value)
    {
        Values[key] = value;
        StateHasChanged(); // Trigger re-render for variable updates
    }

    private bool GetBoolValue(string key)
    {
        if (Values.TryGetValue(key, out var value) && value is bool b)
        {
            return b;
        }

        return false;
    }

    private void SetBoolValue(string key, bool value)
    {
        Values[key] = value;
        StateHasChanged(); // Trigger re-render for variable updates
    }

    /// <summary>
    /// Set checkbox value and clear children if unchecked.
    /// Also handles mutually exclusive fields.
    /// </summary>
    private void SetCheckboxValue(string key, bool value)
    {
        Values[key] = value;

        // If checking this checkbox, handle mutually exclusive fields
        if (value)
        {
            var field = Fields.FirstOrDefault(f => f.Key == key);
            if (field?.MutuallyExclusiveWith != null)
            {
                foreach (var exclusiveKey in field.MutuallyExclusiveWith)
                {
                    // Uncheck the mutually exclusive field
                    if (Values.ContainsKey(exclusiveKey))
                    {
                        Values[exclusiveKey] = false;
                        // Also clear its children
                        ClearChildValues(exclusiveKey);
                    }
                }
            }
        }
        else
        {
            // If unchecking, clear all child field values
            ClearChildValues(key);
        }

        StateHasChanged();
    }

    #endregion

    #region Price Calculations

    /// <summary>
    /// Check if any field has a price set.
    /// </summary>
    private bool HasPricedFields => Fields.Any(f => f.Price.HasValue && f.Price.Value > 0);

    /// <summary>
    /// Get the current calculated total of all priced fields.
    /// This can be called from parent components via @ref.
    /// </summary>
    public decimal GetTotal() => CalculateTotal();

    /// <summary>
    /// Calculate the subtotal for a specific field based on its type and current value.
    /// Only calculates if the field is visible.
    /// </summary>
    private decimal CalculateSubtotal(FormField field)
    {
        // Only calculate for visible fields
        if (!IsFieldVisible(field))
            return 0;

        if (!field.Price.HasValue || field.Price.Value == 0)
            return 0;

        switch (field.Type)
        {
            case FormFieldType.Checkbox:
                // Add price if checked
                return GetBoolValue(field.Key) ? field.Price.Value : 0;

            case FormFieldType.Number:
                // Multiply price by quantity
                var numStr = GetStringValue(field.Key);
                if (decimal.TryParse(numStr, out var qty) && qty > 0)
                    return field.Price.Value * qty;
                return 0;

            case FormFieldType.Select:
            case FormFieldType.RadioGroup:
                // If selected value is numeric, multiply by price; otherwise just add price if selected
                var selStr = GetStringValue(field.Key);
                if (string.IsNullOrEmpty(selStr))
                    return 0;
                // Try to parse as number
                if (decimal.TryParse(selStr, out var selQty))
                {
                    // If numeric (including 0), multiply by price
                    return selQty >= 0 ? field.Price.Value * selQty : 0;
                }
                // Non-numeric selection (like "yes", "option1"): just add price once
                return field.Price.Value;

            default:
                return 0;
        }
    }

    /// <summary>
    /// Calculate the grand total of all priced fields.
    /// </summary>
    private decimal CalculateTotal()
    {
        decimal total = 0;
        foreach (var field in Fields)
        {
            total += CalculateSubtotal(field);
        }
        return total;
    }

    #endregion

    #region Variable Replacement

    /// <summary>
    /// Replace variables like {price}, {subtotal}, {total} in text.
    /// </summary>
    private string ReplaceVariables(string? text, FormField currentField)
    {
        if (string.IsNullOrEmpty(text))
            return string.Empty;

        var result = text;

        // {price} - the price of the current field
        if (result.Contains("{price}"))
        {
            var priceStr = currentField.Price.HasValue 
                ? currentField.Price.Value.ToString("C") 
                : "$0.00";
            result = result.Replace("{price}", $"<span class=\"text-primary fw-bold\">{priceStr}</span>");
        }

        // {subtotal} - the calculated subtotal for the current field
        if (result.Contains("{subtotal}"))
        {
            var subtotal = CalculateSubtotal(currentField);
            result = result.Replace("{subtotal}", $"<span class=\"text-success fw-bold\">{subtotal:C}</span>");
        }

        // {total} - the grand total of all fields
        if (result.Contains("{total}"))
        {
            var total = CalculateTotal();
            result = result.Replace("{total}", $"<span class=\"text-success fw-bold fs-4\">{total:C}</span>");
        }

        return result;
    }

    /// <summary>
    /// Replace variables for radio option text (uses field's price for {price}).
    /// </summary>
    private string ReplaceVariablesForOption(string? text, FormField parentField)
    {
        if (string.IsNullOrEmpty(text))
            return string.Empty;

        var result = text;

        // {price} - the price of the parent field
        if (result.Contains("{price}"))
        {
            var priceStr = parentField.Price.HasValue 
                ? parentField.Price.Value.ToString("C") 
                : "$0.00";
            result = result.Replace("{price}", $"<span class=\"text-primary fw-bold\">{priceStr}</span>");
        }

        return result;
    }

    #endregion

    #region Types

    public enum FormFieldType
    {
        Text,
        Number,
        Date,
        Checkbox,
        Select,
        StaticText,
        RadioGroup
    }

    public class FormField
    {
        /// <summary>
        /// Unique key for this field; used to store values in the dictionary.
        /// </summary>
        public string Key { get; set; } = string.Empty;

        /// <summary>
        /// Label shown above the input. Supports {price}, {subtotal}, {total} variables.
        /// </summary>
        public string Label { get; set; } = string.Empty;

        /// <summary>
        /// Type of control to render.
        /// </summary>
        public FormFieldType Type { get; set; }

        /// <summary>
        /// Optional placeholder for text/number/select fields.
        /// </summary>
        public string? Placeholder { get; set; }

        /// <summary>
        /// Optional label used for checkbox controls. Supports {price}, {subtotal}, {total} variables.
        /// </summary>
        public string? CheckboxLabel { get; set; }

        /// <summary>
        /// Optional help text shown under the field. Supports {price}, {subtotal}, {total} variables.
        /// </summary>
        public string? HelpText { get; set; }

        /// <summary>
        /// Optional default value for this field.
        /// </summary>
        public object? DefaultValue { get; set; }

        /// <summary>
        /// Optional price for calculations. Used with {price}, {subtotal}, {total} variables.
        /// </summary>
        public decimal? Price { get; set; }

        /// <summary>
        /// Optional parent field key. If set, this field is only visible when the parent checkbox is checked,
        /// or always visible if parent is StaticText.
        /// </summary>
        public string? ParentFieldKey { get; set; }

        /// <summary>
        /// Optional list of field keys that are mutually exclusive with this checkbox.
        /// When this checkbox is checked, all fields in this list will be unchecked (and their children cleared).
        /// Example: "I will attend" and "I am unable to attend" should be mutually exclusive.
        /// </summary>
        public List<string>? MutuallyExclusiveWith { get; set; }

        /// <summary>
        /// Options for select and radio group controls.
        /// </summary>
        public List<FormFieldOption>? Options { get; set; }
    }

    public class FormFieldOption
    {
        public string Value { get; set; } = string.Empty;
        public string Text { get; set; } = string.Empty;
    }

    #endregion
}
