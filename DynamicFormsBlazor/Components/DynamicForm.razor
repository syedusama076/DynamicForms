@using System.Collections.Generic
@using System.Linq
@using System.Text.RegularExpressions

<form class="aoa-form" @onsubmit="HandleSubmit">
            @* AOA-style global required note - matches exact structure of field labels *@
            <div class="mb-2 aoa-horizontal-group aoa-label-narrow">
                <label class="form-label fw-bold mb-0">
                    <span class="text-danger fst-italic">* Required</span>
                </label>
                <div></div>
            </div>

            @foreach (var field in Fields)
            {
                @if (IsFieldVisible(field))
                {
                    var nestingLevel = GetNestingLevel(field);
                    var marginLeft = nestingLevel * 24; // 24px per nesting level
                    var isHorizontalField = field.Type != FormFieldType.Checkbox
                                            && field.Type != FormFieldType.StaticText
                                            && field.Type != FormFieldType.RadioGroup
                                            && field.Type != FormFieldType.Table;
                    
                    // Calculate label width dynamically based on label text length
                    var labelText = GetDisplayLabel(field);
                    var cleanLabelText = System.Text.RegularExpressions.Regex.Replace(labelText, "<[^>]*>", ""); // Remove HTML tags
                    var labelLength = cleanLabelText.Length;
                    var labelWidthClass = labelLength > 50 ? "aoa-label-wide" : "aoa-label-narrow";

                    <div class="mb-3 @(isHorizontalField ? $"aoa-horizontal-group {labelWidthClass}" : string.Empty)" 
                         style="@(nestingLevel > 0 ? $"margin-left: {marginLeft}px; padding-left: 12px; border-left: 2px solid #dee2e6;" : "")">
                        @if (field.Type != FormFieldType.Checkbox && field.Type != FormFieldType.StaticText && field.Type != FormFieldType.RadioGroup && field.Type != FormFieldType.Table)
                        {
                            <label class="form-label fw-bold">@((MarkupString)labelText)</label>
                        }
                        @if (field.Type == FormFieldType.Table && !string.IsNullOrWhiteSpace(field.Label))
                        {
                            <label class="form-label fw-bold mb-2">@((MarkupString)ReplaceVariables(field.Label, field))</label>
                        }

                        @switch (field.Type)
                        {
                            case FormFieldType.Text:
                                <input class="form-control"
                                       type="text"
                                       placeholder="@field.Placeholder"
                                       value="@GetStringValue(field.Key)"
                                       @oninput="e => SetStringValue(field.Key, e.Value?.ToString())"
                                       required="@field.IsRequired" />
                                break;

                            case FormFieldType.Number:
                                <input class="form-control"
                                       type="number"
                                       placeholder="@field.Placeholder"
                                       value="@GetStringValue(field.Key)"
                                       @oninput="e => SetStringValue(field.Key, e.Value?.ToString())"
                                       required="@field.IsRequired" />
                                break;

                            case FormFieldType.Date:
                                <input class="form-control"
                                       type="date"
                                       value="@GetStringValue(field.Key)"
                                       @oninput="e => SetStringValue(field.Key, e.Value?.ToString())"
                                       required="@field.IsRequired" />
                                break;

                            case FormFieldType.Checkbox:
                                <div class="form-check">
                                    <input class="form-check-input"
                                           type="checkbox"
                                           checked="@(GetBoolValue(field.Key))"
                                           @onchange="e => SetCheckboxValue(field.Key, (bool?)e.Value ?? false)" />
                                    <label class="form-check-label">@((MarkupString)ReplaceVariables(field.CheckboxLabel ?? field.Label, field))</label>
                                </div>
                                break;

                            case FormFieldType.RadioGroup:
                                @if (field.Options is not null && field.Options.Count > 0)
                                {
                                    @foreach (var option in field.Options)
                                    {
                                        <div class="form-check">
                                            <input class="form-check-input"
                                                   type="radio"
                                                   name="@field.Key"
                                                   id="@($"{field.Key}_{option.Value}")"
                                                   value="@option.Value"
                                                   checked="@(GetStringValue(field.Key) == option.Value)"
                                                   @onchange="@((ChangeEventArgs e) => { SetStringValue(field.Key, e.Value?.ToString() ?? option.Value); })" />
                                            <label class="form-check-label" for="@($"{field.Key}_{option.Value}")">
                                                @((MarkupString)ReplaceVariablesForOption(option.Text, field, option))
                                            </label>
                                        </div>
                                    }
                                }
                                break;

                            case FormFieldType.Select:
                                <select class="form-select"
                                        value="@GetStringValue(field.Key)"
                                        @onchange="e => SetStringValue(field.Key, e.Value?.ToString())"
                                        required="@field.IsRequired">
                                    @if (!string.IsNullOrWhiteSpace(field.Placeholder))
                                    {
                                        <option value="">@field.Placeholder</option>
                                    }

                                    @if (field.Options is not null)
                                    {
                                        @foreach (var option in field.Options)
                                        {
                                            var displayText = ReplaceVariablesForOption(option.Text, field, option);
                                            <option value="@option.Value">@((MarkupString)displayText)</option>
                                        }
                                    }
                                </select>
                                break;

                            case FormFieldType.StaticText:
                                <p class="mb-0 fw-semibold">@((MarkupString)ReplaceVariables(field.Label, field))</p>
                                break;

                            case FormFieldType.Table:
                                @if (field.Options is not null && field.Options.Count > 0)
                                {
                                    var tableData = GetTableData(field.Key);
                                    <div class="table-responsive">
                                        <table class="table table-bordered">
                                            <thead>
                                                <tr>
                                                    @foreach (var column in field.Options)
                                                    {
                                                        <th>@column.Text</th>
                                                    }
                                                    <th style="width: 80px;">Actions</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                @for (int rowIndex = 0; rowIndex < tableData.Count; rowIndex++)
                                                {
                                                    var currentRowIndex = rowIndex; // Capture the index to avoid closure issues
                                                    var row = tableData[rowIndex];
                                                    <tr>
                                                        @foreach (var column in field.Options)
                                                        {
                                                            var columnConfig = ParseTableColumnConfig(column.Value);
                                                            var columnKey = columnConfig.Key;
                                                            var cellValue = row.ContainsKey(columnKey) ? row[columnKey]?.ToString() : "";
                                                            <td>
                                                                @if (columnConfig.Type == "Checkbox")
                                                                {
                                                                    <div class="form-check d-flex justify-content-center">
                                                                        <input class="form-check-input" 
                                                                               type="checkbox" 
                                                                               checked="@(cellValue == "true" || cellValue == "True" || cellValue == "1")"
                                                                               @onchange="e => UpdateTableCell(field.Key, currentRowIndex, columnKey, ((bool?)e.Value ?? false).ToString())" />
                                                                    </div>
                                                                }
                                                                else if (columnConfig.Type == "Select" && columnConfig.Options != null && columnConfig.Options.Count > 0)
                                                                {
                                                                    <select class="form-select form-select-sm" 
                                                                            value="@cellValue"
                                                                            @onchange="e => UpdateTableCell(field.Key, currentRowIndex, columnKey, e.Value?.ToString())">
                                                                        <option value="">-- Select --</option>
                                                                        @foreach (var option in columnConfig.Options)
                                                                        {
                                                                            <option value="@option.Value">@option.Text</option>
                                                                        }
                                                                    </select>
                                                                }
                                                                else if (columnConfig.Type == "Number")
                                                                {
                                                                    <input type="number" 
                                                                           class="form-control form-control-sm" 
                                                                           value="@cellValue"
                                                                           step="any"
                                                                           @oninput="e => UpdateTableCell(field.Key, currentRowIndex, columnKey, e.Value?.ToString())" />
                                                                }
                                                                else
                                                                {
                                                                    <input type="text" 
                                                                           class="form-control form-control-sm" 
                                                                           value="@cellValue"
                                                                           @oninput="e => UpdateTableCell(field.Key, currentRowIndex, columnKey, e.Value?.ToString())" />
                                                                }
                                                            </td>
                                                        }
                                                        <td>
                                                            <button type="button" 
                                                                    class="btn btn-sm btn-danger" 
                                                                    @onclick="() => RemoveTableRow(field.Key, currentRowIndex)"
                                                                    title="Remove row">
                                                                Ã—
                                                            </button>
                                                        </td>
                                                    </tr>
                                                }
                                            </tbody>
                                        </table>
                                    </div>
                                    <button type="button" 
                                            class="btn btn-sm btn-primary mt-2" 
                                            @onclick="() => AddTableRow(field.Key, field.Options)">
                                        + Add Row
                                    </button>
                                }
                                else
                                {
                                    <div class="alert alert-warning">No columns defined for this table. Please configure columns in the form designer.</div>
                                }
                                break;
                        }

                        @if (!string.IsNullOrWhiteSpace(field.HelpText))
                        {
                            <div class="form-text">@((MarkupString)ReplaceVariables(field.HelpText, field))</div>
                        }
                    </div>
                }
            }

            <div class="aoa-form-footer">
                @* Always show total if there are priced fields - matches field label structure *@
                @if (HasPricedFields)
                {
                    <div class="mb-3 aoa-horizontal-group aoa-label-narrow aoa-grand-total-row">
                        <label class="form-label fw-bold mb-0">
                            <span class="aoa-grand-total-label">Grand Total (USD):</span>
                        </label>
                        <div>
                            <span class="aoa-grand-total-amount">@CalculateTotal().ToString("0.##")</span>
                        </div>
                    </div>
                }

                <div class="aoa-footer-actions">
                    <button type="submit" class="btn btn-primary">@SubmitText</button>
                </div>
            </div>
        </form>

@code {
    [Parameter]
    public List<FormField> Fields { get; set; } = new();

    [Parameter]
    public string SubmitText { get; set; } = "Submit";

    /// <summary>
    /// The current form values. The key is the field Key, the value is the user input.
    /// </summary>
    [Parameter]
    public Dictionary<string, object?> Values { get; set; } = new();

    /// <summary>
    /// Fired when the user submits the form.
    /// </summary>
    [Parameter]
    public EventCallback<Dictionary<string, object?>> OnSubmit { get; set; }

    protected override void OnInitialized()
    {
        // Ensure all fields have an entry in the values dictionary
        foreach (var field in Fields)
        {
            if (field.Type != FormFieldType.StaticText && !Values.ContainsKey(field.Key))
            {
                if (field.Type == FormFieldType.Table)
                {
                    // Initialize table with empty list
                    Values[field.Key] = new List<Dictionary<string, object?>>();
                }
                else
                {
                    Values[field.Key] = field.DefaultValue;
                }
            }
        }
    }

    private async Task HandleSubmit()
    {
        if (OnSubmit.HasDelegate)
        {
            await OnSubmit.InvokeAsync(Values);
        }
    }

    #region Nesting / Conditional Visibility

    /// <summary>
    /// Check if a field should be visible based on its parent's state.
    /// </summary>
    private bool IsFieldVisible(FormField field)
    {
        // No parent = always visible
        if (string.IsNullOrEmpty(field.ParentFieldKey))
            return true;

        // Find the parent field
        var parent = Fields.FirstOrDefault(f => f.Key == field.ParentFieldKey);
        if (parent == null)
            return true; // Parent not found, show anyway

        // Check if parent is visible first (recursive)
        if (!IsFieldVisible(parent))
            return false;

        // StaticText parent = always show children (no condition)
        if (parent.Type == FormFieldType.StaticText)
        {
            return true;
        }

        // Checkbox parent = must be checked
        if (parent.Type == FormFieldType.Checkbox)
        {
            return GetBoolValue(parent.Key);
        }

        // For other parent types, show if parent has a value
        var parentValue = GetStringValue(parent.Key);
        return !string.IsNullOrEmpty(parentValue);
    }

    /// <summary>
    /// Get the nesting level of a field (0 = root, 1 = child, 2 = grandchild, etc.)
    /// </summary>
    private int GetNestingLevel(FormField field)
    {
        int level = 0;
        var currentKey = field.ParentFieldKey;

        while (!string.IsNullOrEmpty(currentKey))
        {
            level++;
            var parent = Fields.FirstOrDefault(f => f.Key == currentKey);
            currentKey = parent?.ParentFieldKey;

            // Safety check to prevent infinite loops
            if (level > 10) break;
        }

        return level;
    }

    /// <summary>
    /// Clear values of all child fields when a parent is unchecked.
    /// </summary>
    private void ClearChildValues(string parentKey)
    {
        var children = Fields.Where(f => f.ParentFieldKey == parentKey);
        foreach (var child in children)
        {
            if (child.Type == FormFieldType.Checkbox)
            {
                Values[child.Key] = false;
            }
            else if (child.Type == FormFieldType.RadioGroup)
            {
                Values[child.Key] = null;
            }
            else if (child.Type == FormFieldType.Table)
            {
                Values[child.Key] = new List<Dictionary<string, object?>>();
            }
            else if (child.Type != FormFieldType.StaticText)
            {
                Values[child.Key] = null;
            }

            // Recursively clear grandchildren
            ClearChildValues(child.Key);
        }
    }

    #endregion

    #region Value Getters/Setters

    private string GetStringValue(string key)
    {
        if (Values.TryGetValue(key, out var value) && value is not null)
        {
            return Convert.ToString(value) ?? string.Empty;
        }

        return string.Empty;
    }

    private void SetStringValue(string key, string? value)
    {
        Values[key] = value;
        StateHasChanged(); // Trigger re-render for variable updates
    }

    private bool GetBoolValue(string key)
    {
        if (Values.TryGetValue(key, out var value) && value is bool b)
        {
            return b;
        }

        return false;
    }

    private void SetBoolValue(string key, bool value)
    {
        Values[key] = value;
        StateHasChanged(); // Trigger re-render for variable updates
    }

    /// <summary>
    /// Set checkbox value and clear children if unchecked.
    /// Also handles mutually exclusive fields.
    /// </summary>
    private void SetCheckboxValue(string key, bool value)
    {
        Values[key] = value;

        // If checking this checkbox, handle mutually exclusive fields
        if (value)
        {
            var field = Fields.FirstOrDefault(f => f.Key == key);
            if (field?.MutuallyExclusiveWith != null)
            {
                foreach (var exclusiveKey in field.MutuallyExclusiveWith)
                {
                    // Uncheck the mutually exclusive field
                    if (Values.ContainsKey(exclusiveKey))
                    {
                        Values[exclusiveKey] = false;
                        // Also clear its children
                        ClearChildValues(exclusiveKey);
                    }
                }
            }
        }
        else
        {
            // If unchecking, clear all child field values
            ClearChildValues(key);
        }

        StateHasChanged();
    }

    #endregion

    #region Price Calculations

    /// <summary>
    /// Check if any field has a price set (either field-level or option-level).
    /// </summary>
    private bool HasPricedFields => Fields.Any(f => 
        (f.Price.HasValue && f.Price.Value > 0) || 
        (f.Options != null && f.Options.Any(o => o.Price.HasValue && o.Price.Value > 0)));

    /// <summary>
    /// Get the current calculated total of all priced fields.
    /// This can be called from parent components via @ref.
    /// </summary>
    public decimal GetTotal() => CalculateTotal();

    /// <summary>
    /// Calculate the subtotal for a specific field based on its type and current value.
    /// Only calculates if the field is visible.
    /// </summary>
    private decimal CalculateSubtotal(FormField field)
    {
        // Only calculate for visible fields
        if (!IsFieldVisible(field))
            return 0;

        switch (field.Type)
        {
            case FormFieldType.Checkbox:
                // Add price if checked
                if (field.Price.HasValue && field.Price.Value > 0)
                    return GetBoolValue(field.Key) ? field.Price.Value : 0;
                return 0;

            case FormFieldType.Number:
                // Multiply price by quantity
                if (field.Price.HasValue && field.Price.Value > 0)
                {
                    var numStr = GetStringValue(field.Key);
                    if (decimal.TryParse(numStr, out var qty) && qty > 0)
                        return field.Price.Value * qty;
                }
                return 0;

            case FormFieldType.Select:
            case FormFieldType.RadioGroup:
                var selStr = GetStringValue(field.Key);
                if (string.IsNullOrEmpty(selStr))
                    return 0;
                
                // Check if the selected option has a specific price (priority)
                var selectedOption = field.Options?.FirstOrDefault(o => o.Value == selStr);
                if (selectedOption?.Price.HasValue == true && selectedOption.Price.Value > 0)
                {
                    // Use option-specific price
                    return selectedOption.Price.Value;
                }
                
                // Fall back to field-level price if no option price is set
                if (field.Price.HasValue && field.Price.Value > 0)
                {
                    // Try to parse as number
                    if (decimal.TryParse(selStr, out var selQty))
                    {
                        // If numeric (including 0), multiply by price
                        return selQty >= 0 ? field.Price.Value * selQty : 0;
                    }
                    // Non-numeric selection (like "yes", "option1"): just add price once
                    return field.Price.Value;
                }
                
                return 0;

            default:
                return 0;
        }
    }

    /// <summary>
    /// Calculate the grand total of all priced fields.
    /// </summary>
    private decimal CalculateTotal()
    {
        decimal total = 0;
        foreach (var field in Fields)
        {
            total += CalculateSubtotal(field);
        }
        return total;
    }

    #endregion

    #region Variable Replacement

    /// <summary>
    /// Replace variables like {price}, {subtotal}, {total} in text.
    /// </summary>
    private string ReplaceVariables(string? text, FormField currentField)
    {
        if (string.IsNullOrEmpty(text))
            return string.Empty;

        var result = text;

        // {price} - the price of the current field
        if (result.Contains("{price}"))
        {
            var priceStr = currentField.Price.HasValue 
                ? currentField.Price.Value.ToString("C") 
                : "$0.00";
            result = result.Replace("{price}", $"<span class=\"text-primary fw-bold\">{priceStr}</span>");
        }

        // {subtotal} - the calculated subtotal for the current field
        if (result.Contains("{subtotal}"))
        {
            var subtotal = CalculateSubtotal(currentField);
            result = result.Replace("{subtotal}", $"<span class=\"text-success fw-bold\">{subtotal:C}</span>");
        }

        // {total} - the grand total of all fields
        if (result.Contains("{total}"))
        {
            var total = CalculateTotal();
            result = result.Replace("{total}", $"<span class=\"text-success fw-bold fs-4\">{total:C}</span>");
        }

        return result;
    }

    /// <summary>
    /// Build the display label for a field, including required asterisk and colon,
    /// while still supporting {price}/{subtotal}/{total} variables.
    /// </summary>
    private string GetDisplayLabel(FormField field)
    {
        var baseLabel = ReplaceVariables(field.Label, field) ?? string.Empty;

        // Ensure trailing colon like the original form, if there is any label text.
        if (!string.IsNullOrWhiteSpace(baseLabel) && !baseLabel.TrimEnd().EndsWith(":"))
        {
            baseLabel += ":";
        }

        // Prefix required asterisk when needed.
        if (field.IsRequired)
        {
            // Red asterisk similar to typical required styling.
            baseLabel = $"<span class=\"text-danger\">*</span> {baseLabel}";
        }

        return baseLabel;
    }

    /// <summary>
    /// Replace variables for radio/select option text (uses option's price if available, otherwise field's price).
    /// </summary>
    private string ReplaceVariablesForOption(string? text, FormField parentField, FormFieldOption? option = null)
    {
        if (string.IsNullOrEmpty(text))
            return string.Empty;

        var result = text;

        // {price} - the price of the option (if set) or the parent field
        if (result.Contains("{price}"))
        {
            decimal? price = null;
            if (option?.Price.HasValue == true && option.Price.Value > 0)
            {
                price = option.Price;
            }
            else if (parentField.Price.HasValue && parentField.Price.Value > 0)
            {
                price = parentField.Price;
            }
            
            var priceStr = price.HasValue 
                ? price.Value.ToString("C") 
                : "$0.00";
            result = result.Replace("{price}", $"<span class=\"text-primary fw-bold\">{priceStr}</span>");
        }

        return result;
    }

    #endregion

    #region Table Management

    // Helper class for table column configuration
    private class TableColumnConfig
    {
        public string Key { get; set; } = string.Empty;
        public string Type { get; set; } = "Text";
        public List<TableColumnOption>? Options { get; set; }
    }

    // Helper class for table column dropdown options
    private class TableColumnOption
    {
        public string Value { get; set; } = string.Empty;
        public string Text { get; set; } = string.Empty;
        public decimal? Price { get; set; }
    }

    private TableColumnConfig ParseTableColumnConfig(string value)
    {
        try
        {
            // Try to parse as JSON (new format)
            var config = System.Text.Json.JsonSerializer.Deserialize<TableColumnConfig>(value);
            if (config != null && !string.IsNullOrEmpty(config.Key))
            {
                return config;
            }
        }
        catch
        {
            // If parsing fails, try old format (List<string>)
            try
            {
                var oldOptions = System.Text.Json.JsonSerializer.Deserialize<List<string>>(value);
                if (oldOptions != null)
                {
                    // Convert old format to new format
                    return new TableColumnConfig
                    {
                        Key = value,
                        Type = "Text",
                        Options = oldOptions.Select(o => new TableColumnOption { Value = o, Text = o, Price = null }).ToList()
                    };
                }
            }
            catch { }
        }

        // Final fallback: treat value as key (backward compatibility)
        return new TableColumnConfig
        {
            Key = value,
            Type = "Text",
            Options = null
        };
    }

    /// <summary>
    /// Get table data as a list of dictionaries (rows).
    /// </summary>
    private List<Dictionary<string, object?>> GetTableData(string key)
    {
        if (Values.TryGetValue(key, out var value) && value is not null)
        {
            try
            {
                // Try to deserialize as list of dictionaries
                var json = System.Text.Json.JsonSerializer.Serialize(value);
                var result = System.Text.Json.JsonSerializer.Deserialize<List<Dictionary<string, object?>>>(json);
                return result ?? new List<Dictionary<string, object?>>();
            }
            catch
            {
                // If deserialization fails, return empty list
                return new List<Dictionary<string, object?>>();
            }
        }
        return new List<Dictionary<string, object?>>();
    }

    /// <summary>
    /// Update a specific cell in the table.
    /// </summary>
    private void UpdateTableCell(string tableKey, int rowIndex, string columnKey, string? value)
    {
        var tableData = GetTableData(tableKey);
        
        // Ensure we have enough rows
        while (tableData.Count <= rowIndex)
        {
            tableData.Add(new Dictionary<string, object?>());
        }

        // Update the cell value
        tableData[rowIndex][columnKey] = value;
        
        // Save back to Values
        Values[tableKey] = tableData;
        StateHasChanged();
    }

    /// <summary>
    /// Add a new row to the table.
    /// </summary>
    private void AddTableRow(string tableKey, List<FormFieldOption>? columns)
    {
        var tableData = GetTableData(tableKey);
        var newRow = new Dictionary<string, object?>();
        
        // Initialize all columns with empty values
        if (columns is not null)
        {
            foreach (var column in columns)
            {
                var columnConfig = ParseTableColumnConfig(column.Value);
                var columnKey = columnConfig.Key;
                
                // Set default value based on column type
                if (columnConfig.Type == "Checkbox")
                {
                    newRow[columnKey] = false;
                }
                else
                {
                    newRow[columnKey] = string.Empty;
                }
            }
        }
        
        tableData.Add(newRow);
        Values[tableKey] = tableData;
        StateHasChanged();
    }

    /// <summary>
    /// Remove a row from the table.
    /// </summary>
    private void RemoveTableRow(string tableKey, int rowIndex)
    {
        var tableData = GetTableData(tableKey);
        if (rowIndex >= 0 && rowIndex < tableData.Count)
        {
            tableData.RemoveAt(rowIndex);
            Values[tableKey] = tableData;
            StateHasChanged();
        }
    }

    #endregion

    #region Types

    public enum FormFieldType
    {
        Text,
        Number,
        Date,
        Checkbox,
        Select,
        StaticText,
        RadioGroup,
        Table
    }

    public class FormField
    {
        /// <summary>
        /// Unique key for this field; used to store values in the dictionary.
        /// </summary>
        public string Key { get; set; } = string.Empty;

        /// <summary>
        /// Label shown above the input. Supports {price}, {subtotal}, {total} variables.
        /// </summary>
        public string Label { get; set; } = string.Empty;

        /// <summary>
        /// Type of control to render.
        /// </summary>
        public FormFieldType Type { get; set; }

        /// <summary>
        /// Whether this field is required.
        /// </summary>
        public bool IsRequired { get; set; }

        /// <summary>
        /// Optional placeholder for text/number/select fields.
        /// </summary>
        public string? Placeholder { get; set; }

        /// <summary>
        /// Optional label used for checkbox controls. Supports {price}, {subtotal}, {total} variables.
        /// </summary>
        public string? CheckboxLabel { get; set; }

        /// <summary>
        /// Optional help text shown under the field. Supports {price}, {subtotal}, {total} variables.
        /// </summary>
        public string? HelpText { get; set; }

        /// <summary>
        /// Optional default value for this field.
        /// </summary>
        public object? DefaultValue { get; set; }

        /// <summary>
        /// Optional price for calculations. Used with {price}, {subtotal}, {total} variables.
        /// </summary>
        public decimal? Price { get; set; }

        /// <summary>
        /// Optional parent field key. If set, this field is only visible when the parent checkbox is checked,
        /// or always visible if parent is StaticText.
        /// </summary>
        public string? ParentFieldKey { get; set; }

        /// <summary>
        /// Optional list of field keys that are mutually exclusive with this checkbox.
        /// When this checkbox is checked, all fields in this list will be unchecked (and their children cleared).
        /// Example: "I will attend" and "I am unable to attend" should be mutually exclusive.
        /// </summary>
        public List<string>? MutuallyExclusiveWith { get; set; }

        /// <summary>
        /// Options for select and radio group controls.
        /// </summary>
        public List<FormFieldOption>? Options { get; set; }
    }

    public class FormFieldOption
    {
        public string Value { get; set; } = string.Empty;
        public string Text { get; set; } = string.Empty;
        public decimal? Price { get; set; }
    }

    #endregion
}
