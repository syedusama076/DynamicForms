@using System.Collections.Generic
@using System.Linq
@using System.Text.RegularExpressions

<div class="card">
    <div class="card-body">
        <form @onsubmit="HandleSubmit">
            @foreach (var field in Fields)
            {
                <div class="mb-3">
                    @if (field.Type != FormFieldType.Checkbox && field.Type != FormFieldType.StaticText)
                    {
                        <label class="form-label">@((MarkupString)ReplaceVariables(field.Label, field))</label>
                    }

                    @switch (field.Type)
                    {
                        case FormFieldType.Text:
                            <input class="form-control"
                                   type="text"
                                   placeholder="@field.Placeholder"
                                   value="@GetStringValue(field.Key)"
                                   @oninput="e => SetStringValue(field.Key, e.Value?.ToString())" />
                            break;

                        case FormFieldType.Number:
                            <input class="form-control"
                                   type="number"
                                   placeholder="@field.Placeholder"
                                   value="@GetStringValue(field.Key)"
                                   @oninput="e => SetStringValue(field.Key, e.Value?.ToString())" />
                            break;

                        case FormFieldType.Date:
                            <input class="form-control"
                                   type="date"
                                   value="@GetStringValue(field.Key)"
                                   @oninput="e => SetStringValue(field.Key, e.Value?.ToString())" />
                            break;

                        case FormFieldType.Checkbox:
                            <div class="form-check">
                                <input class="form-check-input"
                                       type="checkbox"
                                       checked="@(GetBoolValue(field.Key))"
                                       @onchange="e => SetBoolValue(field.Key, (bool?)e.Value ?? false)" />
                                <label class="form-check-label">@((MarkupString)ReplaceVariables(field.CheckboxLabel ?? field.Label, field))</label>
                            </div>
                            break;

                        case FormFieldType.Select:
                            <select class="form-select"
                                    value="@GetStringValue(field.Key)"
                                    @onchange="e => SetStringValue(field.Key, e.Value?.ToString())">
                                @if (!string.IsNullOrWhiteSpace(field.Placeholder))
                                {
                                    <option value="">@field.Placeholder</option>
                                }

                                @if (field.Options is not null)
                                {
                                    @foreach (var option in field.Options)
                                    {
                                        <option value="@option.Value">@option.Text</option>
                                    }
                                }
                            </select>
                            break;

                        case FormFieldType.StaticText:
                            <p class="mb-0 fs-5">@((MarkupString)ReplaceVariables(field.Label, field))</p>
                            break;
                    }

                    @if (!string.IsNullOrWhiteSpace(field.HelpText))
                    {
                        <div class="form-text">@((MarkupString)ReplaceVariables(field.HelpText, field))</div>
                    }
                </div>
            }

            @* Always show total if there are priced fields *@
            @if (HasPricedFields)
            {
                <div class="card bg-light mb-3">
                    <div class="card-body py-2">
                        <div class="d-flex justify-content-between align-items-center">
                            <span class="fw-bold">Grand Total:</span>
                            <span class="text-success fw-bold fs-4">@CalculateTotal().ToString("C")</span>
                        </div>
                    </div>
                </div>
            }

            <button type="submit" class="btn btn-primary">@SubmitText</button>
        </form>
    </div>
</div>

@code {
    [Parameter]
    public List<FormField> Fields { get; set; } = new();

    [Parameter]
    public string SubmitText { get; set; } = "Submit";

    /// <summary>
    /// The current form values. The key is the field Key, the value is the user input.
    /// </summary>
    [Parameter]
    public Dictionary<string, object?> Values { get; set; } = new();

    /// <summary>
    /// Fired when the user submits the form.
    /// </summary>
    [Parameter]
    public EventCallback<Dictionary<string, object?>> OnSubmit { get; set; }

    protected override void OnInitialized()
    {
        // Ensure all fields have an entry in the values dictionary
        foreach (var field in Fields)
        {
            if (field.Type != FormFieldType.StaticText && !Values.ContainsKey(field.Key))
            {
                Values[field.Key] = field.DefaultValue;
            }
        }
    }

    private async Task HandleSubmit()
    {
        if (OnSubmit.HasDelegate)
        {
            await OnSubmit.InvokeAsync(Values);
        }
    }

    #region Value Getters/Setters

    private string GetStringValue(string key)
    {
        if (Values.TryGetValue(key, out var value) && value is not null)
        {
            return Convert.ToString(value) ?? string.Empty;
        }

        return string.Empty;
    }

    private void SetStringValue(string key, string? value)
    {
        Values[key] = value;
        StateHasChanged(); // Trigger re-render for variable updates
    }

    private bool GetBoolValue(string key)
    {
        if (Values.TryGetValue(key, out var value) && value is bool b)
        {
            return b;
        }

        return false;
    }

    private void SetBoolValue(string key, bool value)
    {
        Values[key] = value;
        StateHasChanged(); // Trigger re-render for variable updates
    }

    #endregion

    #region Price Calculations

    /// <summary>
    /// Check if any field has a price set.
    /// </summary>
    private bool HasPricedFields => Fields.Any(f => f.Price.HasValue && f.Price.Value > 0);

    /// <summary>
    /// Get the current calculated total of all priced fields.
    /// This can be called from parent components via @ref.
    /// </summary>
    public decimal GetTotal() => CalculateTotal();

    /// <summary>
    /// Calculate the subtotal for a specific field based on its type and current value.
    /// </summary>
    private decimal CalculateSubtotal(FormField field)
    {
        if (!field.Price.HasValue || field.Price.Value == 0)
            return 0;

        switch (field.Type)
        {
            case FormFieldType.Checkbox:
                // Add price if checked
                return GetBoolValue(field.Key) ? field.Price.Value : 0;

            case FormFieldType.Number:
                // Multiply price by quantity
                var numStr = GetStringValue(field.Key);
                if (decimal.TryParse(numStr, out var qty) && qty > 0)
                    return field.Price.Value * qty;
                return 0;

            case FormFieldType.Select:
                // If selected value is numeric, multiply by price; otherwise just add price if selected
                var selStr = GetStringValue(field.Key);
                if (string.IsNullOrEmpty(selStr))
                    return 0;
                // Try to parse as number
                if (decimal.TryParse(selStr, out var selQty))
                {
                    // If numeric (including 0), multiply by price
                    return selQty >= 0 ? field.Price.Value * selQty : 0;
                }
                // Non-numeric selection (like "yes", "option1"): just add price once
                return field.Price.Value;

            default:
                return 0;
        }
    }

    /// <summary>
    /// Calculate the grand total of all priced fields.
    /// </summary>
    private decimal CalculateTotal()
    {
        decimal total = 0;
        foreach (var field in Fields)
        {
            total += CalculateSubtotal(field);
            Console.WriteLine($"Field: {field.Key}, Subtotal: {CalculateSubtotal(field)}");
        }
        return total;
    }

    #endregion

    #region Variable Replacement

    /// <summary>
    /// Replace variables like {price}, {subtotal}, {total} in text.
    /// </summary>
    private string ReplaceVariables(string? text, FormField currentField)
    {
        if (string.IsNullOrEmpty(text))
            return string.Empty;

        var result = text;

        // {price} - the price of the current field
        if (result.Contains("{price}"))
        {
            var priceStr = currentField.Price.HasValue 
                ? currentField.Price.Value.ToString("C") 
                : "$0.00";
            result = result.Replace("{price}", $"<span class=\"text-primary fw-bold\">{priceStr}</span>");
        }

        // {subtotal} - the calculated subtotal for the current field
        if (result.Contains("{subtotal}"))
        {
            var subtotal = CalculateSubtotal(currentField);
            result = result.Replace("{subtotal}", $"<span class=\"text-success fw-bold\">{subtotal:C}</span>");
        }

        // {total} - the grand total of all fields
        if (result.Contains("{total}"))
        {
            var total = CalculateTotal();
            result = result.Replace("{total}", $"<span class=\"text-success fw-bold fs-4\">{total:C}</span>");
        }

        return result;
    }

    #endregion

    #region Types

    public enum FormFieldType
    {
        Text,
        Number,
        Date,
        Checkbox,
        Select,
        StaticText
    }

    public class FormField
    {
        /// <summary>
        /// Unique key for this field; used to store values in the dictionary.
        /// </summary>
        public string Key { get; set; } = string.Empty;

        /// <summary>
        /// Label shown above the input. Supports {price}, {subtotal}, {total} variables.
        /// </summary>
        public string Label { get; set; } = string.Empty;

        /// <summary>
        /// Type of control to render.
        /// </summary>
        public FormFieldType Type { get; set; }

        /// <summary>
        /// Optional placeholder for text/number/select fields.
        /// </summary>
        public string? Placeholder { get; set; }

        /// <summary>
        /// Optional label used for checkbox controls. Supports {price}, {subtotal}, {total} variables.
        /// </summary>
        public string? CheckboxLabel { get; set; }

        /// <summary>
        /// Optional help text shown under the field. Supports {price}, {subtotal}, {total} variables.
        /// </summary>
        public string? HelpText { get; set; }

        /// <summary>
        /// Optional default value for this field.
        /// </summary>
        public object? DefaultValue { get; set; }

        /// <summary>
        /// Optional price for calculations. Used with {price}, {subtotal}, {total} variables.
        /// </summary>
        public decimal? Price { get; set; }

        /// <summary>
        /// Options for select controls.
        /// </summary>
        public List<FormFieldOption>? Options { get; set; }
    }

    public class FormFieldOption
    {
        public string Value { get; set; } = string.Empty;
        public string Text { get; set; } = string.Empty;
    }

    #endregion
}
